[
  {
    "objectID": "hashing.html#final-assignment-of-the-semester",
    "href": "hashing.html#final-assignment-of-the-semester",
    "title": "Hashing",
    "section": "Final assignment of the semester ",
    "text": "Final assignment of the semester \nFix collisions in this (incorrect!) implementation\nclass Dictionary:\n  def __init__(self, capacity):\n    self._data = [None] * capacity\n    # hint: you'll probably want to delete all the self._next\n    # stuff, and implement a totally different hash function\n    self._next = 0\n  \n  def hash(value):\n    index = self._next\n    self._next = self._next + 1 if self._next &lt; len(self._data) - 1 else 0\n    return index\n  \n  def put(self, key, value):\n    index = self.hash(key)\n    self._data[index] = (key, value)\n  \n  def get(self, key):\n    index = self.hash(key)\n    return self._data[index]\nExtra credit for creative hash functions, collision strategies"
  },
  {
    "objectID": "badDictCode.html",
    "href": "badDictCode.html",
    "title": "CSc 120",
    "section": "",
    "text": "class Dictionary:\n  def __init__(self, capacity):\n    self._data = [None] * capacity\n    self._next = 0\n  \n  def hash(value):\n    index = self._next\n    self._next = self._next + 1 if self._next &lt; len(self._data) - 1 else 0\n    return index\n  \n  def put(self, key, value):\n    index = self.hash(key)\n    self._data[index] = (key, value)\n  \n  def get(self, key):\n    index = self.hash(key)\n    return self._data[index]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CSC 120: Introduction to Computer Programming II",
    "section": "",
    "text": "This is a fake course website for a job talk"
  },
  {
    "objectID": "index.html#fall-2024",
    "href": "index.html#fall-2024",
    "title": "CSC 120: Introduction to Computer Programming II",
    "section": "Fall 2024",
    "text": "Fall 2024\n(pretend there’s a syllabus, office hours, etc. here!)"
  },
  {
    "objectID": "index.html#lectures",
    "href": "index.html#lectures",
    "title": "CSC 120: Introduction to Computer Programming II",
    "section": "Lectures",
    "text": "Lectures\n\nCourse Intro\nPython review\nTesting and Debugging\nInto some python weeds\nLinked Lists\nStacks and Queues\nRecursion\nTrees\nComplexity\nList complexity\nRecursive complexity\nHashing\nPython Extras"
  },
  {
    "objectID": "index.html#assignments",
    "href": "index.html#assignments",
    "title": "CSC 120: Introduction to Computer Programming II",
    "section": "Assignments",
    "text": "Assignments\nAll assignments are due at the beginning of class on the corresponding due date; more info about how grading works in this course\n\n\n\n\nAssignment\nDue Date\nDebrief\n\n\n\n\n0\nSetting up your dev environment\n\nNotes\n\n\n1\nPython code golf\n\nSolution\n\n\n2\nDIY lists\n\nSolution\n\n\n3\nTrees\n\nSolution\n\n\n4\nBenchmarking\n2 May 2024\nSolution\n\n\n5\nDIY dicts\n\nSolution"
  },
  {
    "objectID": "badDictCodeWithHint.html",
    "href": "badDictCodeWithHint.html",
    "title": "CSc 120",
    "section": "",
    "text": "class Dictionary:\n  def __init__(self, capacity):\n    self._data = [None] * capacity\n    # hint: you'll probably want to delete all the self._next\n    # stuff, and implement a totally different hash function\n    self._next = 0\n  \n  def hash(value):\n    index = self._next\n    self._next = self._next + 1 if self._next &lt; len(self._data) - 1 else 0\n    return index\n  \n  def put(self, key, value):\n    index = self.hash(key)\n    self._data[index] = (key, value)\n  \n  def get(self, key):\n    index = self.hash(key)\n    return self._data[index]"
  },
  {
    "objectID": "assignment.html",
    "href": "assignment.html",
    "title": "DIY dicts",
    "section": "",
    "text": "Handle collisions in the (incorrect!) implementation from the lecture:\nclass Dictionary:\n  def __init__(self, capacity):\n    self._data = [None] * capacity\n    # hint: you'll probably want to delete all the self._next\n    # stuff, and implement a totally different hash function\n    self._next = 0\n  \n  def hash(value):\n    index = self._next\n    self._next = self._next + 1 if self._next &lt; len(self._data) - 1 else 0\n    return index\n  \n  def put(self, key, value):\n    index = self.hash(key)\n    self._data[index] = (key, value)\n  \n  def get(self, key):\n    index = self.hash(key)\n    return self._data[index]"
  },
  {
    "objectID": "assignment.html#core-requirements",
    "href": "assignment.html#core-requirements",
    "title": "DIY dicts",
    "section": "",
    "text": "Handle collisions in the (incorrect!) implementation from the lecture:\nclass Dictionary:\n  def __init__(self, capacity):\n    self._data = [None] * capacity\n    # hint: you'll probably want to delete all the self._next\n    # stuff, and implement a totally different hash function\n    self._next = 0\n  \n  def hash(value):\n    index = self._next\n    self._next = self._next + 1 if self._next &lt; len(self._data) - 1 else 0\n    return index\n  \n  def put(self, key, value):\n    index = self.hash(key)\n    self._data[index] = (key, value)\n  \n  def get(self, key):\n    index = self.hash(key)\n    return self._data[index]"
  },
  {
    "objectID": "assignment.html#extra-credit-opportunities",
    "href": "assignment.html#extra-credit-opportunities",
    "title": "DIY dicts",
    "section": "Extra credit opportunities",
    "text": "Extra credit opportunities\nExtra credit for creative hash functions, collision strategies*\n* Solutions that employ forms of acceptable cheating are not eligible for extra credit\nThings to inspect that might help:\n\nLook inside the data.json and test.py files; is the test code using keys in a way that you could exploit to hash quickly, and avoid collitions?\nExtra credit will be awarded separately to the most performant solution for each type of key.\n\n\nRunning and testing your solution\nDownload and extract the assignment\nONLY EDIT the dictionary.py file\nTo test for correctness, run python test.py\nTo test for performance, run python benchmark.py\nAfter the last assignment, that code should look familiar!\n\nAcceptable cheating\nHint: It’s possible to implement this using the existing python dict, and/or ignore the capacity setting to achieve better performance… but unless you make a REALLY compelling argument, doing this won’t qualify you for extra credit\nAs with other assignments in this course, collaboration and creative ways around the problem are encouraged!\nCopypasta from Stackoverflow or AI-generated solutions are also allowed (but discouraged).\nHowever, in all cases when you’re up to something sneaky, you MUST COMMENT YOUR CODE about where you got something that you didn’t write, and/or when you’re sneaking around the problem, or you risk getting a ZERO on the assignment (fully up to the discretion of the instructor).\nIf you attempt, to stay safe, make sure that you include comments that:\n\nGive props about who and how specific classmates helped you\nCite the source websites / tools that helped you, for which chunks of code\nFor workarounds, describe how you’re avoiding the spirit of the assignment—I want to know that you know what you’re doing\n\n\n\n\nWhat to submit\nUpload your modified dictionary.py file here:\n\n\nYour student ID \n\n\nTest my code for potential extra credit!   Please do NOT check this box if we’d be likely to consider your solution to be acceptable cheating\n\n\n\n\n\n\nSubmit\n\n\n\nFor this assignment, submit as many solutions as you like!"
  },
  {
    "objectID": "hashing.html#benchmarking-homework",
    "href": "hashing.html#benchmarking-homework",
    "title": "Hashing",
    "section": "Benchmarking homework",
    "text": "Benchmarking homework\nDebrief / check-in\n\nWhat was the hardest part?\nWhat was fun about it?\nWhat was NOT fun about it?\nIf you did it again, how would you do it differently?"
  },
  {
    "objectID": "hashing.html#the-fastest-search-algorithm",
    "href": "hashing.html#the-fastest-search-algorithm",
    "title": "Hashing",
    "section": "The fastest  search algorithm",
    "text": "The fastest  search algorithm\n\nLinear / sequential (linked list)\n\nItems don’t have to be sorted\nSearch: \\(O(n)\\) Insert, Delete: \\(O(1)\\)\n\n\n\n\nBinary (linked list)\n\nKeep items sorted\nSearch, Insert, Delete: \\(O(log\\ n)\\)\n\n\n\n\n\nMagic search: \\(O(1)\\) to access, insert, delete\n\n\n\n Do you believe me?"
  },
  {
    "objectID": "hashing.html#python",
    "href": "hashing.html#python",
    "title": "Hashing",
    "section": "Python",
    "text": "Python\nclass Dictionary:\n  def __init__(self, capacity):\n    self._data = [None] * capacity\n    self._next = 0\n  \n  def hash(value):\n    index = self._next\n    self._next = self._next + 1 if self._next &lt; len(self._data) - 1 else 0\n    return index\n  \n  def put(self, key, value):\n    index = self.hash(key)\n    self._data[index] = (key, value)\n  \n  def get(self, key):\n    index = self.hash(key)\n    return self._data[index]\n\nWhat if you give it more than capacity values?"
  },
  {
    "objectID": "hashing.html#performance",
    "href": "hashing.html#performance",
    "title": "Hashing",
    "section": "Performance?",
    "text": "Performance?\ntodo"
  },
  {
    "objectID": "hashing.html#correctness",
    "href": "hashing.html#correctness",
    "title": "Hashing",
    "section": "Correctness?",
    "text": "Correctness?\ntodo"
  },
  {
    "objectID": "hashing.html#collisions",
    "href": "hashing.html#collisions",
    "title": "Hashing",
    "section": "Collisions",
    "text": "Collisions\ntodo"
  },
  {
    "objectID": "hashing.html#good-bad-and-ugly-hash-functions",
    "href": "hashing.html#good-bad-and-ugly-hash-functions",
    "title": "Hashing",
    "section": "Good, Bad, and Ugly hash functions",
    "text": "Good, Bad, and Ugly hash functions\ntodo"
  },
  {
    "objectID": "hashing.html#performance-for-real",
    "href": "hashing.html#performance-for-real",
    "title": "Hashing",
    "section": "Performance (for real)",
    "text": "Performance (for real)\ntodo"
  },
  {
    "objectID": "hashing.html#python-dict-irl",
    "href": "hashing.html#python-dict-irl",
    "title": "Hashing",
    "section": "Python dict IRL",
    "text": "Python dict IRL"
  },
  {
    "objectID": "hashing.html#correctness-1",
    "href": "hashing.html#correctness-1",
    "title": "Hashing",
    "section": "Correctness?",
    "text": "Correctness?\ntodo"
  },
  {
    "objectID": "hashing.html#probing",
    "href": "hashing.html#probing",
    "title": "Hashing",
    "section": "Probing",
    "text": "Probing\ntodo"
  },
  {
    "objectID": "hashing.html#nested-structures",
    "href": "hashing.html#nested-structures",
    "title": "Hashing",
    "section": "Nested structures",
    "text": "Nested structures\ntodo"
  },
  {
    "objectID": "hashing.html#double-hashing",
    "href": "hashing.html#double-hashing",
    "title": "Hashing",
    "section": "Double hashing",
    "text": "Double hashing\ntodo"
  },
  {
    "objectID": "hashing.html#load-factor",
    "href": "hashing.html#load-factor",
    "title": "Hashing",
    "section": "Load factor",
    "text": "Load factor\nFor a hash table with \\(N\\) keys and \\(M\\) capacity: \\[\n\\lambda = N / M\n\\]\nLoad factor tells you how full the table is; average number of probes:\n\n\n\\[\n\\frac{1}{2}(1+\\frac{1}{1-\\lambda})\n\\]\n\nfor successful searches\n\n\n\n\n\\[\n\\frac{1}{2}(1+\\frac{1}{(1-\\lambda)^2})\n\\]\n\nfor unsuccessful searches"
  },
  {
    "objectID": "hashing.html#formula",
    "href": "hashing.html#formula",
    "title": "Hashing",
    "section": "Formula",
    "text": "Formula\nHow full is a particular hash table?\nFor a hash table with \\(N\\) keys and \\(M\\) capacity:\n\\[\n\\lambda = N / M\n\\]"
  },
  {
    "objectID": "hashing.html#rule-of-thumb",
    "href": "hashing.html#rule-of-thumb",
    "title": "Hashing",
    "section": "Rule of thumb",
    "text": "Rule of thumb\nAverage number of probes:\n\n\n\\[\n\\frac{1}{2}(1+\\frac{1}{1-\\lambda})\n\\]\n\nfor successful searches\n\n\n\n\n\\[\n\\frac{1}{2}(1+\\frac{1}{(1-\\lambda)^2})\n\\]\n\nfor unsuccessful searches\n\n\n\n\\(\\lambda = 1\\) is pretty bad (approaches ∞)\n\n\n\\(\\lambda &lt; 0.75\\) is … not so bad (\\(2.5\\), \\(8.5\\))"
  },
  {
    "objectID": "hashing.html#probing-double-hashing-hybrid",
    "href": "hashing.html#probing-double-hashing-hybrid",
    "title": "Hashing",
    "section": "Probing, double hashing, hybrid",
    "text": "Probing, double hashing, hybrid\n\nProbing: use neighboring empty cells!\n\n\nDouble hashing: Use an extra function to prevent clustering around common values!\n\n\nHybrid strategies: Default to another data structure!\n\n\n\nAlthough hash tables can often be \\(\\Theta(1)\\) in practice…\ncollisions mean that worst-case performance is \\(O(n)\\)"
  },
  {
    "objectID": "hashing.html#probing-double-hashing-separate-chaining",
    "href": "hashing.html#probing-double-hashing-separate-chaining",
    "title": "Hashing",
    "section": "Probing, double hashing, separate chaining",
    "text": "Probing, double hashing, separate chaining\nProbing: use neighboring empty cells!\n\nDouble hashing: Use an extra function to prevent clustering around common values!\n\n\nSeparate chaining: Default to another data structure!\n\n\n\nAlthough hash tables can often be \\(\\Theta(1)\\) in practice…\ncollisions mean that worst-case performance is \\(O(n)\\)"
  },
  {
    "objectID": "hashing.html#if-you-know-your-keys-are-numbers",
    "href": "hashing.html#if-you-know-your-keys-are-numbers",
    "title": "Hashing",
    "section": "If you know your keys are numbers",
    "text": "If you know your keys are numbers\n\nDigits in order?\n\n\nThis is the basic idea behind Radix sort!\n\n\nWhat if the keys are phone numbers from the same area code?\n\n\n\n\n\nReverse order?\n\n\n\n\nOther ideas?"
  },
  {
    "objectID": "hashing.html#if-you-know-your-keys-are-strings",
    "href": "hashing.html#if-you-know-your-keys-are-strings",
    "title": "Hashing",
    "section": "If you know your keys are strings",
    "text": "If you know your keys are strings\n\nFirst / last letters?\nString length?\nOther ideas?"
  },
  {
    "objectID": "hashing.html#if-you-know-the-keys-are-numbers",
    "href": "hashing.html#if-you-know-the-keys-are-numbers",
    "title": "Hashing",
    "section": "If you know the keys are numbers",
    "text": "If you know the keys are numbers\n\nDigits in order?\n\n\nThis is the basic idea behind Radix sort!\n\n\nWhat if the keys are phone numbers from the same area code?\n\n\n\n\n\nReverse order?\n\n\n\n\nOther ideas?"
  },
  {
    "objectID": "hashing.html#if-you-know-the-keys-are-strings",
    "href": "hashing.html#if-you-know-the-keys-are-strings",
    "title": "Hashing",
    "section": "If you know the keys are strings",
    "text": "If you know the keys are strings\n\nFirst / last letters?\nString length?\nOther ideas?"
  },
  {
    "objectID": "hashing.html#something-else",
    "href": "hashing.html#something-else",
    "title": "Hashing",
    "section": "Something else?",
    "text": "Something else?\n\nCan’t use hash tables with keys that aren’t “hashable”\nWhat “hashable” means… is up to you!\n\nOnly requirement is a (quick!) way to turn keys into numbers that are as uniformly-spread as possible\nIf you’re using someone else’s hash table (e.g. python’s dict), what “hashable” means—and how uniformly the table fills up!—is up to them"
  }
]